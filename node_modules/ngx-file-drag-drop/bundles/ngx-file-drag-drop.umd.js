(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/forms'), require('@angular/cdk/coercion'), require('@angular/common'), require('@angular/material/chips'), require('@angular/material/icon'), require('@angular/material/tooltip')) :
    typeof define === 'function' && define.amd ? define('ngx-file-drag-drop', ['exports', '@angular/core', '@angular/forms', '@angular/cdk/coercion', '@angular/common', '@angular/material/chips', '@angular/material/icon', '@angular/material/tooltip'], factory) :
    (global = global || self, factory(global['ngx-file-drag-drop'] = {}, global.ng.core, global.ng.forms, global.ng.cdk.coercion, global.ng.common, global.ng.material.chips, global.ng.material.icon, global.ng.material.tooltip));
}(this, (function (exports, core, forms, coercion, common, chips, icon, tooltip) { 'use strict';

    var BytePipe = /** @class */ (function () {
        function BytePipe() {
            this.unit = 'Bytes';
        }
        BytePipe.prototype.transform = function (value, decimals) {
            value = value.toString();
            if (parseInt(value, 10) >= 0) {
                value = this.formatBytes(+value, +decimals);
            }
            return value;
        };
        // https://stackoverflow.com/questions/15900485/correct-way-to-convert-size-in-bytes-to-kb-mb-gb-in-javascript
        BytePipe.prototype.formatBytes = function (bytes, decimals) {
            if (decimals === void 0) { decimals = 2; }
            if (bytes === 0) {
                return '0 Bytes';
            }
            var k = 1024;
            var dm = decimals < 0 ? 0 : decimals;
            var sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
            var i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
        };
        return BytePipe;
    }());
    BytePipe.decorators = [
        { type: core.Pipe, args: [{
                    name: 'byte'
                },] }
    ];

    var NgxFileDragDropComponent = /** @class */ (function () {
        function NgxFileDragDropComponent() {
            this.valueChanged = new core.EventEmitter();
            // does no validation, just sets the hidden file input
            this.accept = '*';
            this._disabled = false;
            this._multiple = false;
            this.emptyPlaceholder = "Drop file" + (this.multiple ? 's' : '') + " or click to select";
            this._displayFileSize = false;
            this._activeBorderColor = 'purple';
            this._files = [];
            this._isDragOver = false;
            // https://angular.io/api/forms/ControlValueAccessor
            this._onChange = function (val) { };
            this._onTouched = function () { };
        }
        Object.defineProperty(NgxFileDragDropComponent.prototype, "disabled", {
            get: function () {
                return this._disabled;
            },
            set: function (val) {
                this._disabled = coercion.coerceBooleanProperty(val);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgxFileDragDropComponent.prototype, "multiple", {
            get: function () {
                return this._multiple;
            },
            set: function (value) {
                this._multiple = coercion.coerceBooleanProperty(value);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgxFileDragDropComponent.prototype, "displayFileSize", {
            get: function () {
                return this._displayFileSize;
            },
            set: function (value) {
                this._displayFileSize = coercion.coerceBooleanProperty(value);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgxFileDragDropComponent.prototype, "borderColor", {
            get: function () {
                return this.isDragover ? this._activeBorderColor : '#ccc';
            },
            set: function (color) {
                this._activeBorderColor = color;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgxFileDragDropComponent.prototype, "files", {
            get: function () {
                return this._files;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgxFileDragDropComponent.prototype, "isEmpty", {
            get: function () {
                var _a;
                return !((_a = this.files) === null || _a === void 0 ? void 0 : _a.length);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgxFileDragDropComponent.prototype, "isDragover", {
            // @HostBinding('class.drag-over')
            get: function () {
                return this._isDragOver;
            },
            set: function (value) {
                if (!this.disabled) {
                    this._isDragOver = value;
                }
            },
            enumerable: false,
            configurable: true
        });
        NgxFileDragDropComponent.prototype.writeValue = function (files) {
            var fileArray = this.convertToArray(files);
            if (fileArray.length < 2 || this.multiple) {
                this._files = fileArray;
                this.emitChanges(this._files);
            }
            else {
                throw Error('Multiple files not allowed');
            }
        };
        NgxFileDragDropComponent.prototype.registerOnChange = function (fn) {
            this._onChange = fn;
        };
        NgxFileDragDropComponent.prototype.registerOnTouched = function (fn) {
            this._onTouched = fn;
        };
        NgxFileDragDropComponent.prototype.setDisabledState = function (isDisabled) {
            this.disabled = isDisabled;
        };
        NgxFileDragDropComponent.prototype.emitChanges = function (files) {
            this.valueChanged.emit(files);
            this._onChange(files);
        };
        NgxFileDragDropComponent.prototype.addFiles = function (files) {
            // this._onTouched();
            var fileArray = this.convertToArray(files);
            if (this.multiple) {
                // this.errorOnEqualFilenames(fileArray);
                var merged = this.files.concat(fileArray);
                this.writeValue(merged);
            }
            else {
                this.writeValue(fileArray);
            }
        };
        NgxFileDragDropComponent.prototype.removeFile = function (file) {
            var fileIndex = this.files.indexOf(file);
            if (fileIndex >= 0) {
                var currentFiles = this.files.slice();
                currentFiles.splice(fileIndex, 1);
                this.writeValue(currentFiles);
            }
        };
        NgxFileDragDropComponent.prototype.clear = function () {
            this.writeValue([]);
        };
        NgxFileDragDropComponent.prototype.change = function (event) {
            event.stopPropagation();
            this._onTouched();
            var fileList = event.target.files;
            if (fileList === null || fileList === void 0 ? void 0 : fileList.length) {
                this.addFiles(fileList);
            }
            // clear it so change is triggered if same file is selected again
            event.target.value = '';
        };
        NgxFileDragDropComponent.prototype.activate = function (e) {
            e.preventDefault();
            this.isDragover = true;
        };
        NgxFileDragDropComponent.prototype.deactivate = function (e) {
            e.preventDefault();
            this.isDragover = false;
        };
        NgxFileDragDropComponent.prototype.handleDrop = function (e) {
            var _this = this;
            this.deactivate(e);
            if (!this.disabled) {
                var fileList = e.dataTransfer.files;
                this.removeDirectories(fileList).then(function (files) {
                    if (files === null || files === void 0 ? void 0 : files.length) {
                        _this.addFiles(files);
                    }
                    _this._onTouched();
                });
            }
        };
        NgxFileDragDropComponent.prototype.open = function () {
            var _a;
            if (!this.disabled) {
                (_a = this.fileInputEl) === null || _a === void 0 ? void 0 : _a.nativeElement.click();
            }
        };
        // @HostListener('focusout')
        // blur() {
        //   console.log('blurred')
        //   this._onTouched();
        // }
        // private errorOnEqualFilenames(files: File[]) {
        //   if (this.files.some(file => files.some(file2 => file.name === file2.name))) {
        //     throw Error('one of the provided filenames already exists')
        //   }
        //   for (let i = 0; i < files.length; i++) {
        //     for (let j = i + 1; j < files.length; j++) {
        //       if (files[i].name === files[j].name) {
        //         throw Error(`can't add multiple files with same name`)
        //       }
        //     }
        //   }
        // }
        NgxFileDragDropComponent.prototype.removeDirectories = function (files) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                var fileArray = _this.convertToArray(files);
                var dirnames = [];
                var readerList = [];
                var _loop_1 = function (i) {
                    var reader = new FileReader();
                    reader.onerror = function () {
                        dirnames.push(fileArray[i].name);
                    };
                    reader.onloadend = function () { return addToReaderList(i); };
                    reader.readAsArrayBuffer(fileArray[i]);
                };
                for (var i = 0; i < fileArray.length; i++) {
                    _loop_1(i);
                }
                function addToReaderList(val) {
                    readerList.push(val);
                    if (readerList.length === fileArray.length) {
                        resolve(fileArray.filter(function (file) { return !dirnames.includes(file.name); }));
                    }
                }
            });
        };
        NgxFileDragDropComponent.prototype.convertToArray = function (files) {
            if (files) {
                if (files instanceof File) {
                    return [files];
                }
                else if (Array.isArray(files)) {
                    return files;
                }
                else {
                    return Array.prototype.slice.call(files);
                }
            }
            return [];
        };
        NgxFileDragDropComponent.prototype.getFileName = function (file) {
            if (!this._displayFileSize) {
                return file.name;
            }
            var size = new BytePipe().transform(file.size);
            return file.name + " (" + size + ")";
        };
        return NgxFileDragDropComponent;
    }());
    NgxFileDragDropComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'ngx-file-drag-drop',
                    template: "<mat-chip-list *ngIf=\"files.length\" selectable=\"false\">\r\n    <mat-chip matTooltip={{file.size|byte}} matTooltipPosition=\"below\" [matTooltipDisabled]=\"displayFileSize\" selected\r\n        *ngFor=\"let file of files\" [disabled]=\"disabled\" color=\"accent\" disableRipple=\"true\" [removable]=\"!disabled\"\r\n        (removed)=\"removeFile(file)\">\r\n        <span class=\"filename\">{{getFileName(file)}}</span>\r\n        <mat-icon *ngIf=\"!disabled\" matChipRemove>cancel</mat-icon>\r\n    </mat-chip>\r\n</mat-chip-list>\r\n<span class=\"placeholder\" *ngIf=\"!files.length\">{{emptyPlaceholder}}</span>\r\n<input #fileInputEl class=\"hidden\" #fileInput type=\"file\" [attr.multiple]=\"multiple? '' : null\" [attr.accept]=\"accept\">",
                    providers: [{
                            provide: forms.NG_VALUE_ACCESSOR,
                            useExisting: core.forwardRef(function () { return NgxFileDragDropComponent; }),
                            multi: true
                        }],
                    styles: ["input{height:0;opacity:0;overflow:hidden;position:absolute;width:0;z-index:-1}:host{border:2px dashed;border-radius:20px;cursor:pointer;display:block;margin:10px auto;max-width:500px;min-height:50px;padding:20px}:host.disabled{cursor:unset;opacity:.5}.placeholder{color:grey;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}mat-chip{max-width:100%}.filename{max-width:calc(100% - 1em);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}:host.empty-input{align-items:center;display:flex;justify-content:center}.mat-chip.mat-standard-chip.mat-focus-indicator{box-shadow:none}.mat-chip.mat-standard-chip:after{background:unset}"]
                },] }
    ];
    NgxFileDragDropComponent.ctorParameters = function () { return []; };
    NgxFileDragDropComponent.propDecorators = {
        disabled: [{ type: core.HostBinding, args: ['class.disabled',] }, { type: core.Input }],
        multiple: [{ type: core.Input }],
        displayFileSize: [{ type: core.Input }],
        borderColor: [{ type: core.Input, args: ['activeBorderColor',] }, { type: core.HostBinding, args: ['style.border-color',] }],
        isEmpty: [{ type: core.HostBinding, args: ['class.empty-input',] }],
        valueChanged: [{ type: core.Output }],
        fileInputEl: [{ type: core.ViewChild, args: ['fileInputEl',] }],
        accept: [{ type: core.Input }],
        emptyPlaceholder: [{ type: core.Input }],
        change: [{ type: core.HostListener, args: ['change', ['$event'],] }],
        activate: [{ type: core.HostListener, args: ['dragenter', ['$event'],] }, { type: core.HostListener, args: ['dragover', ['$event'],] }],
        deactivate: [{ type: core.HostListener, args: ['dragleave', ['$event'],] }],
        handleDrop: [{ type: core.HostListener, args: ['drop', ['$event'],] }],
        open: [{ type: core.HostListener, args: ['click',] }]
    };

    var NgxFileDragDropModule = /** @class */ (function () {
        function NgxFileDragDropModule() {
        }
        return NgxFileDragDropModule;
    }());
    NgxFileDragDropModule.decorators = [
        { type: core.NgModule, args: [{
                    declarations: [NgxFileDragDropComponent, BytePipe],
                    imports: [
                        common.CommonModule,
                        chips.MatChipsModule,
                        icon.MatIconModule,
                        tooltip.MatTooltipModule
                    ],
                    exports: [NgxFileDragDropComponent, BytePipe]
                },] }
    ];

    // @dynamic
    var FileValidators = /** @class */ (function () {
        function FileValidators() {
        }
        FileValidators.fileExtension = function (ext) {
            return function (control) {
                var validExtensions = ext.map(function (e) { return e.trim().toLowerCase(); });
                var fileArray = control.value;
                var invalidFiles = fileArray.map(function (file) { return file.name; }).filter(function (fname) {
                    var extension = fname.slice((fname.lastIndexOf('.') - 1 >>> 0) + 2).toLowerCase();
                    return !validExtensions.includes(extension);
                }).map(function (name) { return ({ name: name, ext: name.slice((name.lastIndexOf('.') - 1 >>> 0) + 2) }); });
                return !invalidFiles.length
                    ? null
                    : {
                        fileExtension: {
                            requiredExtension: ext.toString(),
                            actualExtensions: invalidFiles
                        }
                    };
            };
        };
        FileValidators.uniqueFileNames = function (control) {
            var fileNameArray = control.value.map(function (file) { return file.name; });
            var duplicates = fileNameArray.reduce(function (acc, curr) {
                acc[curr] = acc[curr] ? acc[curr] + 1 : 1;
                return acc;
            }, {});
            var duplicatesArray = Object.entries(duplicates)
                .filter(function (arr) { return arr[1] > 1; })
                .map(function (arr) { return ({ name: arr[0], count: arr[1] }); });
            return !duplicatesArray.length
                ? null
                : {
                    uniqueFileNames: { duplicatedFileNames: duplicatesArray }
                };
        };
        FileValidators.fileType = function (types) {
            return function (control) {
                var regExp;
                if (Array.isArray(types)) {
                    var joinedTypes = types.join('$|^');
                    regExp = new RegExp("$" + joinedTypes + "^", 'i');
                }
                else {
                    regExp = types;
                }
                var fileArray = control.value;
                var invalidFiles = fileArray.filter(function (file) { return !regExp.test(file.type); }).map(function (file) { return ({ name: file.name, type: file.type }); });
                return !invalidFiles.length
                    ? null
                    : {
                        fileType: {
                            requiredType: types.toString(),
                            actualTypes: invalidFiles
                        }
                    };
            };
        };
        FileValidators.maxFileCount = function (count) {
            return function (control) {
                var fileCount = (control === null || control === void 0 ? void 0 : control.value) ? control.value.length : 0;
                var result = count >= fileCount;
                return result
                    ? null
                    : {
                        maxFileCount: {
                            maxCount: count,
                            actualCount: fileCount
                        }
                    };
            };
        };
        FileValidators.maxFileSize = function (bytes) {
            return function (control) {
                var fileArray = control.value;
                var invalidFiles = fileArray.filter(function (file) { return file.size > bytes; }).map(function (file) { return ({ name: file.name, size: file.size }); });
                return !invalidFiles.length
                    ? null
                    : {
                        maxFileSize: {
                            maxSize: bytes,
                            actualSizes: invalidFiles
                        }
                    };
            };
        };
        FileValidators.maxTotalSize = function (bytes) {
            return function (control) {
                var size = (control === null || control === void 0 ? void 0 : control.value) ? control.value.map(function (file) { return file.size; }).reduce(function (acc, i) { return acc + i; }, 0) : 0;
                var result = bytes >= size;
                return result
                    ? null
                    : {
                        maxTotalSize: {
                            maxSize: bytes,
                            actualSize: size
                        }
                    };
            };
        };
        FileValidators.required = function (control) {
            var _a;
            var count = (_a = control === null || control === void 0 ? void 0 : control.value) === null || _a === void 0 ? void 0 : _a.length;
            return count
                ? null
                : {
                    required: true
                };
        };
        return FileValidators;
    }());

    /*
     * Public API Surface of ngx-file-drag-drop
     */

    /**
     * Generated bundle index. Do not edit.
     */

    exports.BytePipe = BytePipe;
    exports.FileValidators = FileValidators;
    exports.NgxFileDragDropComponent = NgxFileDragDropComponent;
    exports.NgxFileDragDropModule = NgxFileDragDropModule;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=ngx-file-drag-drop.umd.js.map
